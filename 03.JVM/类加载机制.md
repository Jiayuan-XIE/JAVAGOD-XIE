## 类加载机制概述



### 是什么？

是Java虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，

最终变成可以被虚拟机直接使用的Java类型的过程。



### 语言特性

- 动态加载
- 动态连接

如果是一个面向接口的类，在运行它之前，就不知道到底运行的是哪个实现类



### 类加载的时机

#### 类的生命周期

经历7个阶段：

![image-20210703112337620](http://note.youdao.com/yws/public/resource/7d81e6a39024a96dd86efacf29f4ca80/xmlnote/WEBRESOURCE422400aa96464f68b83ad14a5f314d23/386)



#### 什么时候被“初始化”？

- 遇到 new、getstatic、putstatic或invokestatic，这四条指令时
- 反射调用
- 先初始化其父类
- 虚拟机启动时，指定一个执行的主类（main方法的那个类）
- JDK8之后，接口有default，实现该接口的类被初始化之前，该接口要初始化



### 类加载过程

#### 加载

把外部的二进制字节流按照虚拟机所设定的格式存储在**方法区**中。

具体为三步：

1. 通过类的全限定名来获取类的**二进制字节流**
2. 将字节流所代表的静态结构转化为**方法区的运行时数据结构**
3. 在内存中生成一个java.lang.**Class对象**，作为这个类的各种数据的**访问入口**



#### 验证

确保Class文件里的字节流所包含的信息，符合《Java虚拟机规范》的全部约束要求，防止危害到虚拟机自身安全。



#### 准备

正式为类中定义的变量（static修饰的静态变量）分配内存，并设置初始值（置为0，不是置为设置的值，那个是初始化阶段的事情）

特殊情况：被`final`修饰的话，可以这个时候就设置给定的值。



#### 解析

把**符号引用**替换为**直接引用**。



符号引用：任何形式的字面量，只要能为歧义的定位到目标就行。

直接引用：直接指向目标的指针、相对偏移量或者间接指向的句柄。



#### 初始化

就是执行类构造器\<clinit>方法的过程。

\<clinit>是Javac编译器的自动生成物，不是java代码中的方法。

它是类中所有**类变量的赋值动作**和**静态语句代码块**中的语句合并而成的。



## 类加载器

### 是什么？

是一个动作—”通过一个类的全限定名来获取描述该类的二进制字节流“

就是找到该类。

仅仅用于实现类的加载动作。



### 双亲委派机制

#### 是什么？

一个类收到了类加载请求，他不会立刻自己加载，而是先去找老爸加载（父类加载器），老爸会去找他的老爸，每层都会这样做

最终传到了最顶层的启动类加载器（祖先），只有老爸加载不了（找不到这个类,抛出ClassNotFoundException），才会尝试自己去加载。



#### 类加载器双亲委派模型

三层类加载器：

- 启动类加载器
- 扩展类加载器
- 应用程序类加载器

![image-20210704102546969](http://note.youdao.com/yws/public/resource/7d81e6a39024a96dd86efacf29f4ca80/xmlnote/WEBRESOURCEdef71fdfea184fa7b86a40d562e89e84/387)



#### 优点

起到了一种**优先级加载**的作用，保证了Java程序**安全稳定的运行**（**保证基础类型一致性**）。

（优先加载顶层类库的程序，而不是自己的程序，如自定义重名的类）





## 破坏双亲委派机制

### 方法一：重写loadClass()方法

本身类加载机制的逻辑就在这个方法中写的，重写这个方法就能打破了



### 方法二： 使用线程上下文类加载器

基类调用用户代码，如JNDI服务



















