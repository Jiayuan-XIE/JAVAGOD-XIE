# 数据库基础

## 1.概念

关系数据库是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。



## 2.存储引擎

- MyISAM
- InnoDB

MySQL5.5之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。

**缺点**：MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。



### 比较：

**1.是否支持行级锁**

MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！



**2.是否支持事务**

MyISAM 不提供事务支持。

InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。



**3.是否支持外键**

MyISAM 不支持，而 InnoDB 支持。



**4.是否支持数据库异常崩溃后的安全恢复**

MyISAM 不支持，而 InnoDB 支持。

使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。



**5.是否支持 MVCC**

>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

MyISAM 不支持，而 InnoDB 支持。

讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。

MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。

![image-20210731101313604](http://note.youdao.com/yws/public/resource/7d81e6a39024a96dd86efacf29f4ca80/xmlnote/WEBRESOURCE94c3b6ce3599442e85ba674f9d5f8812/1973)

## 3.锁机制与 InnoDB 锁算法

**MyISAM 和 InnoDB 存储引擎使用的锁：**

- MyISAM 采用表级锁(table-level locking)。
- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁

**表级锁和行级锁对比：**

- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB 存储引擎的锁的算法有三种：**

- Record lock：记录锁，单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身,防止多个事务将记录插入到同一个范围，因为会导致幻读。
- Next-key lock：record+gap临键锁，锁定一个范围，包含记录本身





## 4.事务

要么全都做，要么全都不做

关系型数据库（例如：`MySQL`、`SQL Server`、`Oracle` 等）事务都有 **ACID** 特性：

![事务的特性](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png)

### 4.1何为 ACID 特性呢？

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性**（`Durabilily`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。



### 4.2 如何保证ACID

原子性通过**undo log（重做日志）**来保证；

隔离性通过**锁机制、MVCC**等手段来保证；

持久性通过**redo log（重做日志）**来保证；

一致性通过，**原子性、隔离性、持久性**来保证；



### 4.3 并发带来的问题

- **丢失修改**（W-W）

  T1改了数据D，T2也改了数据D，T2提交的结果破坏了T1提交的结果，导致T1改的丢失了。

  **（T1 T2同时读了一个数据，又都改了）**

- **不可重复读**（R-W-R）

  T1读了，T2改了，T1再次读就发现，前后两次读的数据不一致了。

  **（T1在一个事务中多次读了一个数据，T2中途改了一下）**

- **幻读**（R- A|D -R)

  T1读了一组数据，T2添加（删除）了一些数据，T1再读这组数据发现多出来（少）了一些数据，好像幻觉一样

  **（T1在一个事务中多次读了一个数据，T2中途增删了一些数据）**

- **脏读**（W-R-Undo-R）

  T1修改了数据，T2随之读了该数据，结果T1突然反悔给撤销修改了（恢复原值），T2就读了个脏数据（T1未提交之前可以回滚）
  
  **T2读取了T1未提交的数据，T1随时都有可能回滚，一旦回滚了，T2读的就是个脏数据。**



### 4.4 事务隔离级别有哪些?

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。



| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √    | √          | √    |
| READ-COMMITTED   | ×    | √          | √    |
| REPEATABLE-READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |



### 4.5 实现原理

1.读取未提交

隔离级别最低，很不安全

- 读的时候不加锁；
- 写的时候后，加个**行级共享锁（读锁）**，直到事务结束才释放。

只是保证写的时候，别人不能写。

2.读取已提交

- 读的时候加个**行级共享锁（读锁）**，但是**读完就立即释放锁**（所以不能保证可重复读）
- 写的时候加上**行级排它锁（写锁）**，直到**事务结束**再释放锁（所以防止脏读）

因为写锁要到事务结束才释放，所以别的事务不可能读一个可能会回滚的数据。

3.可重复读

- 读的时候加上**行级共享锁（读锁）**，但是直到**事务结束**才释放锁（防止前后两次读的不一样，可重复读）
- 写的时候加上**行级排他锁（写锁）**，必须直到**事务结束**才释放锁（防止脏读）

因为**读锁到事务结束才释放**，在此期间别的事务都能进行写操作，所以可以重复读。

4.串行化

- 读的时候加上**表级共享锁（读锁）**，直到事务结束才释放。
- 写的时候加上**表级排它锁（写锁）**，直到事务结束才释放。

最高的隔离级别，因为加的是表级锁，所以不能对表进行添加新数据或者删除旧数据，所以可以防止幻读。



### 4.6 MySQL 的默认隔离级别是什么?

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重复读）**。



**MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。**





## 5.范式

### 5.1 第一范式

保证每列的原子性，每列都不可再拆分



#### 例子

不满足：学生表（学号，姓名，身体信息）

满足    ：学生表（学号，姓名，身高，体重）

身体信息可以拆分为，身高，体重



### 5.2 第二范式

消除了非主属性对码的部分函数依赖，

#### 例子

不满足：学生表（学号，身份证号，姓名，地址）

满足    ：学生表（学号，姓名）身份表（身份证号，地址）

主属性是（学号，身份证号）

而“姓名”，只需要依赖学号



### 5.3 第三范式

消除了非主属性对码的传递函数依赖（传递的中间属性是非主属性）

不满足：学生表（学号，姓名，学院，院长）

满足    ：学生表（学号，姓名）学院表（学院，院长）

学号-->学院，学院-->院长

### BCNF范式



## 6.意向锁

对上级的一个标识

当我们对行数据进行加锁的时候，不能再对其所属的表进行加表级锁，

问题是，我如果相对一个表进行加锁，如果没有意向锁，我就得把整张表遍历一遍，才知道能不能加表锁，效率太低。

现在，我们如果对行数据进行加锁，那就把所属的上级，也就是所属的表加上一个意向锁，表示该表不能被加表锁，从而提高效率。



## 7.  SQL注入攻击

本质上是理由构造SQL语句来进行恶意操作。



### 7.1 猜解数据库

利用**`union select`联合查询继续获取信息。**

获取user信息，数据库信息



### 7.2 绕过验证

#### 1）注入恒正确的条件(数字型)

在条件的后边加入一个恒定正确的条件，用or进行连接

```sql
select * from users where id = '1' or 1=1 #' and password='123' or 1=1 #'
```



#### 2）字符串注解截断注入(字符型)

利用注释语法，进行截断，可以绕过部分条件判断

```sql
select * from users where username='123' #' and password='123' or 1=1 #'
```



### 7.3 如何预防

#### 1）严格检查输入变量的类型和格式



#### 2）过滤和转义特殊字符



#### 3）利用mysql的预编译机制

一次编译，多次运行。

具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到mysql服务器，mysql服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。





## 8. MVCC

### 8.1 是什么？

多版本并发控制，是一种尽可能不加锁的并发控制机制，因此开销更低，并发性能更高。

实现了非阻塞的读，写操作也只锁定必要的行。



### 8.2 如何实现

**核心思想**：通过保存数据在某个时间点的快照实现的。

也就是说，一个事务，无论运行多久，它看到的数据都是一样的，是不变的，是事务开始时间的快照。

### 8.3 InnoDB 实现

加了两个隐藏列：

- 创建时间
- 过期时间（删除时间）

这个时间指的是版本号，并不是真的时间值，每开始一个事务，版本号就会递增。

用版本号来指明数据快照。



#### 实现细节

**1）SELECT**

只查找符合两个条件的记录

1. 只看比当前事务版本号相等或者小的行
2. 删除版本要么没定义，要么大于当前版本号



**2）INSERT：**

插入的行，保存当前事务版本号作为行创建版本号



**3）DELETE:**

删除的行，保存当前事务版本号作为行删除版本号



**4）UPDATE**

新旧的值都要保存：

1. 插入一个新记录，保存当前事务版本号作为行版本号。
2. 把原来的行的删除时间，设置为当前事务版本号。

相当于插入了一个新值，删除了旧值。



MVCC只在两个隔离级别生效：

- 读取已提交
- 可重复读



## 9. 三大日志（binlog、redolog、undolog）

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据一致性。



### redo log和binlog区别

- redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。
- redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑
- redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。
- binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。
