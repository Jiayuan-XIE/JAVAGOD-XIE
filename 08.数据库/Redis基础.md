## 1.Redis简介

Redis 是一个使用**C语言开发**的数据库，是一个**高性能**的 **key-value** 数据库。

与传统的数据库不同的是，Redis的数据是存在**内存当中的**，也就是**内存数据库**。

由于读写的速度非常快，因此被广泛的应用于缓存方向。

## 2. 基本数据结构

基本数据结构是Redis对象的底层实现方式

### 2.1 简单动态字符串 SDS

**结构：**

- int len	 	 有效长度
- int free        空闲长度
- char buf[]   字符数组

**特点：**

- **常量级别获取长度**
- **安全**：
  - 杜绝了缓存区溢出（安全的空间分配策略）
  - 二进制安全的（怎么写入的，怎么读出来）
- **高效：伸缩自如**
  - 空间预分配
  - 惰性空间释放
- **兼容C的库函数**



### 2.2 链表

无环双向双端链表

包含两块：

- 链表结构体
  - head
  - tail
  - len
- 链表节点
  - prev
  - next
  - value



### 2.3 字典（map）

键值对，底层用hash表实现

1）**哈希表 hashtable**

类似于java 的HashMap

2）哈希表节点   

- key
- val
- next

3）字典

- type       
- privdata
- **ht[2]**            （两个**hashtable**，一个用来存数据，一个用来rehash)
- **trehashidx**（rehash的标志位）



#### rehash（重新散列）

扩展和收缩哈希表

> 1. 为ht[1] 分配空间，扩展收缩都是2的幂次方
> 2. 把ht[0]上的键值对，放在ht[1]上
> 3. 释放ht[0]，并把ht[1]设置为ht[0]，在ht[1]创建一个空白哈希表，为下次rehash做准备

出于性能考虑，rehash的操作是**渐进式的**。

也就是说，ht[0]的数据，并不是一次性移动到ht[1]上的，而是分多次、渐进式的移动。

两个方面：

- 只要本字典进行CRUD操作，就会顺带把ht[0]的某一个链表rehash到ht[1]上，从而避免集中式的rehash
- 删、改、查会在两个表上进行，增只在ht[1]表上进行，保证了ht[0]只减不增





### 2.4 跳跃表

简称跳表，是一种有序的数据结构，它维持着**跳跃性的指针指向**，从而达到快速访问节点的目的。

#### 复杂度分析

也是一种**空间换时间**的思想。

支持平均O(log N)，最坏O(N)的时间复杂度查找节点。

总体上，跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。

#### 特点

在大部分情况下，效率可以和二叉查找树相媲美，却又拥有较小的维护代价，(和**红黑树**的初衷一样)



### 2.5 整数集合

集合键的底层实现之一

当一个集合只包含整数值元素，且数量较少时，用整数集合来存。

数组，有序，无重复

#### 升级

int16、int32、int64

为了解决内存空间，**需要升级才升级**，并且不能降级



### 2.6 压缩列表

是**列表键**和**哈希键**的底层实现之一

当列表建元素较少，且要么是小整数值，要么是短字符串，就会用压缩列表。

#### 目的

节约内存

#### 结构

连续内存块组成的顺序型数据结构





## 3. 对象类型

为了优化使用效率，每种对象类型的底层实现，都会有两种及以上的实现方式：

- 节约内存的实现方式
- 常规的实现方式

#### 对象的结构

````
- type：类型
- encoding：编码
- ptr：指向底层数据结构的指针
- lru：空转时长，即最后一次被访问的时间
````



### 3.1 String

一个key对应一个value。

**底层编码：**

````
- int（整数值）
- raw（SDS)
- embstr（短字符串优化编码）只用一次分配内存函数
````

**应用场景：**通常用于计数

- 用户访问次数
- 热点文章的点赞转发数量



### 3.2 Hash 哈希

Redis hash 是一个键值对集合。

Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

**底层编码：**

````
- ziplist 压缩列表（当元素长度**小于64字节**、且**元素数量少于512**个的时候，会使用压缩列表）
- hashtable 哈希表
````

**应用场景：**存储对象数据。



### 3.3 List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。

**底层编码：**

````
- ziplist 压缩列表（当元素长度小于64字节、且元素数量少于512个的时候，会使用压缩列表）
- linkedlist 双端双向链表
````



**应用场景：**

- 发布与订阅（消息队列）



### 3.4 Set（集合）

Redis的Set是string类型的无序集合。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

**底层编码：**

````
- intset   整数集合	（当元素都是整数值，且元素个数不超过512个）
- hashtable 哈希表（类似于java 的hashset的实现方式）
````

**应用场景：存放无重复数据**

- 存放无重复数据
- 获取多个数据源的交集和并集的场景（共同关注人，共同的粉丝）



### 3.5 zset(sorted set：有序集合)

Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。

不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

zset的成员是唯一的,但分数(score)却可以重复。

**底层编码：**

````
- ziplist（数量小于128，且元素大小小于64字节）
- skiplist
````

有序集合同时使用**跳表**和**字典**实现。

既保证了分值的O(1)查找效率，也保证了节点的范围有序查找。

**应用场景：**根据某个权重进行排序的情况

- 排行榜



### 3.6 bitmap

思想就是用一个bit位来标记某个元素对应的value或者状态。

好处就是**节约内存**

**应用场景：**记录用户状态信息，并需要进一步分析的场景

- **用户签到情况**：
- **用户活跃情况**：使用时间作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1
- **用户行为统计**：点赞投币，key为视频ID，offset为用户ID，点赞就设为1，否则设为0





## 4. 过期键删除策略

分为主动删除和被动删除

````
- 定时删除（主动）
- 惰性删除（被动）（Rdis使用）
- 定期删除（主动）（Rdis使用）
````

#### 1）定时删除（Redis没有实现，不重要）

使用定时器，时间到了就立刻删除

**优点：**对内存优好，过期的数据不会占用内存

**缺点：**

- 无用的键，会占用CPU资源，影响服务器的响应时间和吞吐量
- 处理效率低



#### 2）惰性删除

平时不管，用到某个键时，若发现过期了，再将它删除

优点：对CPU友好

缺点：对内存不友好，浪费内存空间，有内存泄漏的风险



#### 3）定期删除

每隔一段时间就对数据库进行检测，并删除过期的键。

**是前两种策略的整合和折中**

优点：

- 降低了无用CPU的占用频率
- 不会造成太大的内存浪费



## 5. 持久化

把Redis在内存中的数据状态保存在磁盘上

两种方式：

````
- RDB
- AOF
````

### 5.1 RDB

RDB文件用于保存和还原Redis数据库中的数据，是一个**经过压缩的二进制文件。**

不同类型的键值对，保存的方式不同。

**可手动，也可自动。**

**两种保存命令：**

````
- SAVE
- BGSAVE
````

#### **1）SAVE**（阻塞）

由服务器进程直接执行保存操作，该命令会阻塞服务器

在此期间，不能处理任何命令请求

#### **2）BGSAVE（非阻塞的）**

由子进程进行保存操作，不会阻塞服务器，服务器仍然可以处理命令。

由于不会阻塞服务器，可以设置条件，**自动使用BGSAVE命令进行保存。**

#### 3）RDB载入

载入RDB文件，把文件中的数据读进来

服务器是阻塞状态，直到载入完成



### 5.2 AOF

AOF(Append Only File)

和RDB不同，AOF保存的是命令。

#### 1）持久化实现

````
1. 追加
2. 写入
3. 同步
````

追加：把**写**命令追加到aof_buf缓冲区里**（注意，是写命令）**

写入：把缓冲区里的数据写入到AOF文件里

同步：保存AOF文件



#### 2）持久化的效率与安全

三种持久化方式：

````shell
- always	# 写入立即同步
- everysec	# 写入隔一秒同步
- no		# 写入，操作系统决定什么时候同步
````

效率与安全

````shell
- always	# 效率最低，安全性最高
- everysec	# 效率和安全性都还行，可能会丢失1秒的命令数据
- no		# 写的快，同步慢，整体效率还行，安全性最差，会丢失上次AOF同步之后的所有命令
````



#### 3）载入与数据还原

**载入：**重新执行一下AOF文件里的命令就行了。

用一个伪客户端，来执行载入的命令



#### 4）AOF重写（非阻塞的）

如果一直追加命令，AOF文件会越来越大。

为了解决AOF膨胀问题，Redis提供了文件重写功能（AOF命令优化）

>实际上并没有重写AOF文件，只是读当前的数据库状态，用批量写命令来保存状态，以达到减少命令个数的目的。

为了防止阻塞服务器进程，开一个子进程用来重写AOF

**步骤：**

````
1. 创建一个新的AOF文件
2. 子进程进行命令重写
3. 重写完成，向服务器进程发信号：我重写完了
4. 服务器进程把AOF重写缓冲区中的内容，追加新AOF文件中
5. 替换老的AOF文件
````

在过程中，服务器进程：

- 正常执行客户端命令
- 命令追加到AOF缓冲区中
- 命令追加到**重写AOF**缓冲区中（多了这一步）

因为在子进程重写AOF的过程中，服务器进程仍然接受客户端命令，这个时候的命令也要保存，所以使用了**重写AOF缓冲区**。



## 6. Redis事务

严格意义上讲

Redis不支持A（原子性），支持（CID）一致性、隔离性、持久性（在AOF的always模式下）



### 6.1 事务的过程

三个命令控制着事务：`MULTI` `EXEC` `WATCH`

三个阶段：

````
1）事务开始	# MULTI命令标志着事务的开始
2）命令入队	# 暂不执行，放队列里
3）命令执行	# EXEC命令，开始执行队列里的事务，先进先出
````

`WATCH`命令用来监视数据库键，是一种乐观锁

如果被`WATCH`监视的键的值被修改了，服务器就拒绝执行事务。



### 6.3 四大特性

1）原子性

Redis没有回滚机制，所以不具备原子性



2）一致性

命令错误，服务器停机，并不会造成数据的不一致



3）隔离性

因为Redis是单线程的，是串行化的，所以具有隔离性



4）持久性

只有在AOF模式下以及同步方式为always的情况下，才具有持久性。



