# 锁的专题

## 1. 乐观锁与悲观锁

### 是什么？

是一种态度，是一种风格

> 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展
>
> 悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展

他们无好坏之分，对应着不同的场景



#### 乐观锁

总是假设最好的情况，我是一个乐观的仔，每次去拿数据的时候都认为别人不会修改，所以不会上锁，（我相信别人不会拿的）

但是在更新（写）的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。



场景：适用于**多读**场景，可以提高吞吐量



#### 悲观锁

总是假设最坏情况，我是一个悲观的仔，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，（我不相信别人，都别动，我先来）

这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。



场景：适用于**多写**场景，防止出现并发问题。



### 乐观锁的实现方式

#### 1）CAS算法

即**compare and swap**（比较并替换）

**CAS算法**涉及到三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换整体是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。



#### 缺点：

1. ##### ABA问题

   两次读的值一样，就代表这个值没有被改变过吗？未必，中间改了，但又改回来了

2. ##### CPU开销问题

   自旋CAS，如果长时间不成功，会给CPU带来很大的负担

3. ##### 只能保证单个共享变量的原子操作

   CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。



#### 如何解决ABA问题？

加标志位，就是类似于版本号version

或者时间戳



#### 2）版本号控制

读的时候，记录下版本号version==1，

每次写的时候，先检测version是不是之前读的值

若是，则认为没人修改值，++version == 2

若不是，则有别人在此期间修改了值，我的操作被驳回。





### 悲观锁

sychronized是悲观锁

#### sychronized锁优化（JDK1.6之后）

锁的状态总共有四种：

- 无锁状态
- 偏向锁
- 轻量级锁
- 重量级锁

随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的**升级是单向**的，也就是说只能从低到高升级，不会出现锁的降级

>  偏向锁==》轻量级锁==》重量级锁

![img](http://note.youdao.com/yws/public/resource/7d81e6a39024a96dd86efacf29f4ca80/xmlnote/WEBRESOURCE7d2ad35833d545c0abf758656e531b4b/709)

其中：轻量级锁失败了再来个自旋锁优化一下，自旋锁失败了，再膨胀为重量级锁



#### 锁升级的大致过程

针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，

就是先使用偏向锁优先同一线程然后再次获取锁，

如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。

最后如果以上都失败就升级为重量级锁。



#### 场景

偏向锁：**线程没有竞争**，适合一个线程对一个锁多次获取的情况，且将来只有第一个申请锁的线程会使用锁。

轻量级锁：**无实际竞争**，多个线程交替使用锁；允许短时间的锁竞争，它只适用于共享数据的锁定状态很短的场景。

重量级锁：**线程竞争很激烈**，且锁竞争时间长。



#### 偏向锁

它是一种针对加锁操作的优化手段，偏向锁是**针对于一个线程**而言的, 

> **过程：**线程在访问同步块获得锁时，会在对象头中存储偏向的线程ID，之后就**不会再有加锁解锁**等操作了，只需要简单的测试一下对象头中的Mark Word里是否存着指向当前线程的偏向锁, 这样可以省略很多开销. 

（**偏向于**第一个获取锁的线程，就把锁给他，不加锁解锁了）

假如有**两个线程来竞争该锁话**, 那么偏向锁就失效了, 进而升级成**轻量级锁**了.

因为大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得（那就没必要加锁）

因此，为了减少**同一线程多次获取锁的代价**，从而引入偏向锁，没有**锁竞争**

> 场景： 适用于只有一个线程访问同步块的场景



##### 偏向锁的升级

当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线**程1是否存活，如果没有存活，那么锁对象被重置为无锁状态**，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。



#### 轻量级锁

倘若偏向锁失败，虚拟机**并不会立即升级为重量级锁**，它还会尝试使用一种称**为轻量级锁**的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。

> **过程：**可以先采用 **CAS 操作进行同步，使用CAS操作将对象的请求头中的Mark Word替换为指向自己线程栈帧锁记录的指针，如果 CAS 失败了，尝试自旋锁，自旋失败了再改用互斥量进行同步，即重量锁。**

轻量级锁是相对于传统的重量级锁而言，**它使用 CAS 操作来避免重量级锁使用互斥量的开销**。

轻量级锁能够提升程序性能的依据是“**对绝大部分的锁，在整个同步周期内都不存在竞争**”，注意这是经验数据。

> 场景：适用于**多个线程交替执行同步块的场合**，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。



#### 自旋锁（轻量级锁之后的一种优化手段，在重量级锁之前）

轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。

**（挂起的代价太高，我坚信一会就能拿到锁了，我就自己转悠转悠（自旋），看看在此期间能不能拿到锁）（上厕所，小的）**

最后没办法也就只能升级为**重量级锁**了。

> 场景：共享数据的锁定状态很短



#### 锁消除

Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)

通过对运行上下文的扫描，**去除不可能存在共享资源竞争的锁**。



#### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

如果虚拟机探测到由这样的**一串零碎的操作都对同一个对象加锁**，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

````java
public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    //粗化
    sb.append(s1);//本来是一个append的锁，现在加在3个连续append锁的外边
    sb.append(s2);
    sb.append(s3);
    //粗化
    return sb.toString();
    
}
````





## 2. ReentrantLock锁

和synchronized一样是可重入锁

区别：

- 等待可中断
- 可实现公平锁
- 可实现选择通知



## 3. 共享锁与排它锁

### 3.1 共享锁—读锁

多个线程可以对一个共享对象进行加共享锁，可以共享的读，但都不能写。



### 3.2 排他锁—写锁

只有一个线程可以获得这个对象的排他锁，别人都不能拒之门外，既不能读，也不能写。

只有当前线程可对这个对象进行读写操作。

