# Java小知识

## 基本数据类型表示范围

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg)

范围通式：2[n-1]   ~   2 [n-1]-1

解释：

- 为什么是[n-1]？

  答：因为有一位用来当符号位

- 为什么右边要   -1？

  答：因为是从0开始的。

- 为什么左边不  -1？

  答：因为有两个0，+0和-0，而-0充当了-128使用（假设是byte类型）。

- 为什么-0能充当-128使用？

  因为它俩的补码是一致的，（-128截断后的补码和-0的补码一致），并且拿这个补码进行运算时，结果就是用-128参与的运算的结果。

-128补码1 1000 0000 ; -0补码 1000 0000; 

由于byte是8位，所以-128截断变成 1000 0000，与-0补码相同。

例子：-128 + 1，进行补码运算

1000 0000

+

0000 0001

=

1000 0001

转化原码为：1111 1111

结果为-127。



### 知识点补充

对于有符号数，二进制的最高位表示正负。

反码：为了负数的加法诞生（计算机不会减法），正数的反码是本身，负数的反码是除符号位，其他取反。

补码：为了解决-0的问题，只用反码，会产生-0，正数的补码是本身，负数的补码是除符号位，其他取反，再加一。





## 方法的重写和重载

| 区别点     | 重载方法 | 重写方法                                                     |
| ---------- | -------- | ------------------------------------------------------------ |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |

**方法的重写要遵循“两同两小一大”**（以下内容摘录自《疯狂 Java 讲义》,[issue#892](https://github.com/Snailclimb/JavaGuide/issues/892) ）：

- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。





## 深拷贝vs浅拷贝

Java有两种数据类型：基本数据类型和引用型。

Java都是值传递，这对于基本数据类型没啥问题，但是对于引用型，容易出问题。

当一个使用**组合**的设计的对象，进行拷贝时，内部的组合对象只会引用传递（A拷贝给B，但是他们共享这个内部的组合对象）。

如果对B中的组合对象进行状态修改，那么A中的组合对象也会相应的改变，这就是很大的隐患。

### 本质

> “深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。”

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。

![deep and shallow copy](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg)

只需要为对象图的每一层的每一个对象都实现Cloneable接口并重写clone方法，最后在最顶层的类的重写的clone方法中调用所有的clone方法即可实现深拷贝。

简单的说就是：每一层的每个对象都进行浅拷贝=深拷贝。即，不仅外部对象拷贝，内部组合对象也拷贝，就行了。



如何进行深拷贝？

两种方法：

- 重写clone
- 对象序列化（记得学完JVM来研究一下）





## 面向对象与面向过程对比

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。



## 自动拆装箱

### Integer

自动拆箱：`Integer.intValue(int i)`

自动装箱：`Integer.valueOf(int i)`

![image-20210706105807153](http://note.youdao.com/yws/public/resource/7d81e6a39024a96dd86efacf29f4ca80/xmlnote/WEBRESOURCEb6b5b26bbe2545528ce0f3d2f3455484/419)

>结果：
>
>true
>false
>true
>true
>false
>false
>true

![image-20210706110008474](http://note.youdao.com/yws/public/resource/7d81e6a39024a96dd86efacf29f4ca80/xmlnote/WEBRESOURCE0c0fa65fe375439ea07a5c0478dcae9c/420)



## String、StringBuffer与StringBuilder

|              |                            String                            |                 StringBuffer                 |                        StringBuilder                         |
| :----------: | :----------------------------------------------------------: | :------------------------------------------: | :----------------------------------------------------------: |
|     长度     |                            不可变                            |                     可变                     |                             可变                             |
| 是否线程安全 |                            不安全                            |                     安全                     |                            不安全                            |
|     性能     | 如果需要频繁改变字符串，性能就很差，每次修改字符串都会创建一个新的对象，效率低下且浪费内存空间 | 较差，因为要保证线程安全，所以需要一定的开销 | 性能比StringBuffer好，但是线程不安全，如果不需要线程安全，是个不错的选择 |

如果字符串**不需要频繁改变**，那就用String就行了，节省空间。

如果字符串**频繁改变**，**且需要线程安全**，那就用StringBuffer。

如果字符串**频繁改变，但不需要线程安全**，那就用StringBuilder，因为**速度快。**

