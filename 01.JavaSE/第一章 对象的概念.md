# 对象的概念



### 为什么要面向对象？

程序猿必须在问题空间和解决方案空间之间建立一种关联，十分的费神。

即，你需要先分析问题，然后再站在计算机的思维角度来描述分析后的结果，从而建立解决方案空间，十分麻烦。

而面向对象思想打通了他们之间的隔阂，站在人的角度来建立问题空间，通过“对象”来描述实体（万物皆对象），使得编程更加灵活和强大。



> 面向对象的终极指标：可维护性、可复用性、可扩展性



## 封装

### 封装是什么？

对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。

- 把属性和方法的实现**隐藏**起来
- 把方法的接口**暴露**在外



### 为什么要封装？

- 降低操作复杂度

  只需了解公开的接口，无需了解实现细节。

- 解耦

  良好的封装可以有效的降低耦合度。

- **安全性**

  他人无法篡改被私有化的成员。

  **使用户不要接触他们不该接触的部分**。

-  **可维护性**
   
    研发程序猿知道别人无法篡改他私有化的东西，所以可以放心的修改（优化）工具类，而不会影响之前的调用。

  



### 怎么做封装？

四个关键字来管理：

- `public`（公开）谁都可访问。
- `private`（私有）只有类本身和内部方法能访问。
- `protected`（受保护）除了自己访问自己，自家的**后代**也可以访问。
- `default`（默认）同一个**包**下的可以访问（同小区的可以访问）。



但是注意：类的访问权限就两种：

- 包访问权限
- public

如果你实在不想被外界访问，那就把构造器设置为私有的。

这样你只能在本类中的**static成员**里创建自己的对象了。



## 复用

![image-20200921201545846](https://img-blog.csdnimg.cn/20200929110037830.png#pic_center)

这种关系称之为**组合**，应优先考虑组合，而不是**继承**，代码会更加的简洁灵活，更加清晰。（滥用继承会使得程序拙劣复杂）



## 继承

两种设计：

- 纯粹代替：子类与父类的接口完全一致（儿子继承家业）
- 非纯粹代替：子类对父类有扩展（儿子不光继承了家业，并扩充了别的业务）

有人说**纯粹代替**是一种理想的设计方式，但其实各个都有自己的适合的场合。



## 多态

之前对这个词语一直很迷惑，什么“父类的引用指向子类的对象”、“对象的多态”、“方法的多态”，说了一堆，就是不明白。

原因是都在讲多态的使用方式或者说表现形式，而没有说为什么要使用多态，他的使用场景是什么。

那来举个例子吧！

>小明开了家理发店，洗剪吹普通价20块，会员价15块。
>
>老板小明只负责剪发，不管是哪类用户一样的剪
>
>每次剪完头发，老板娘小红坐到收银台对客户举起支付宝二维码，进行收费。
>
>看到墙上的标价，客户自己就知道该给15还是20块钱，老板娘只需要看看支付宝到账了没有。

在这里，**会员**和**非会员**是**客户**的子类，是**客户**的多种形态，他们在理发结束后都要交钱，具体交多少，那就看自己是哪类客户啦！

发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）

这个叫**后期绑定**，即编译的时候，不知道是哪个具体的代码被调用（反正理发阶段都是一样的，平等的），直到运行的时候才能确定（交钱的时候再确定是哪种会员）。

把子类看做父类来处理，这个叫**向上转型**。



>小明的店日益兴隆，为了赚钱，开始推销新卡---钻石会员、黄金会员、白银会员
>
>但无论多少种，理完发后，按照自己的身份交钱就是啦！



## 集合

大多高级程序设计语言都支持“数组”，而Java提供了更丰富的集合类型，常用的有：

- List	用来保存有序序列
- Map  键值对
- Set    用来保存**非重复**的元素

还有其他的集合，各有各的应用场景。

在`Java5`之前，集合里只保存Object类型，所有的类在存入集合中时候，都会转化成Object（所有的类也都是Object的子类），所以这种子类转化成父类的行为，也被成为`向上转型`。

存的时候是很方便，但是取出来的时候十分危险，因为父亲有多个儿子嘛，万一打错了儿子(向下转型)，不就麻烦大了嘛！

是Java5提出了一个概念`泛型`,明确规定这个集合只能存哪个儿子。

````java
ArrayList<Shape> shapes = new ArrayList<>(); 
````



## 对象的创建与生命周期

对象的生存是需要资源的，而资源是有限的，对资源的合理利用才能使项目更加稳定的运行。

而如何合理的清理没用的对象呢？这个就比较棘手了。

对象有两种存储方式：

- 栈
  - C++效率优先，因此把这个权利直接交给了程序猿，在编程的时候就已经指定了某个对象的生老病死，自己控制，效率贼高。
  - 缺陷也很明显，不通用啊，对特定的场景还好，在通用的场景就比较难受。
- 堆
  - 动态创建对象，直到程序运行的时候，才知道对象的生死时刻。
  - Java的垃圾收集器会自动处理处理对象，这使得其编码难度比C++要小很多。



## 异常

常在河边走哪有不湿鞋，总有出现异常的时候，关键在于如何去处理。

Java提供了异常处理机制，出现异常时，捕获它，然后去处理就行了，并不会干扰程序的正常运行。
